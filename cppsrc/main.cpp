/* cppsrc/main.cpp */

#include <napi.h>
#include <cstdint>
#include <string>
#include <cmath>
#include <functional>

// ////////////////////////////////////////////////////////////////////////////////////////

/**
 * Total number of bits allocated to an ID
*/
int TOTAL_BITS = 64;

/**
 * Total number of bits allocated to an epoch timestamp
*/
int EPOCH_BITS = 42;

/**
 * Total number of bits allocated to an node/machine id
*/
int NODE_ID_BITS = 10;

/**
 * Total number of bits allocated to an sequencing
*/
int SEQUENCE_BITS = 12;

/** 
 * Max node that can be used
*/
uint64_t maxNodeId = std::pow(2, NODE_ID_BITS) - 1;

// ////////////////////////////////////////////////////////////////////////////////////////

/**
 * Covert the macID string passed as a parameter
 * into a hash value and return the bitwise & with maxNodeID
 * so that the hashed value is always smaller than maxNodeID 
 * which is 10 bits in size
*/
int nodeID(std::string macID)
{
    return std::hash<std::string>()(macID) % maxNodeId;
}

// ////////////////////////////////////////////////////////////////////////////////////////

/**
 * Takes the current timestamp, last timestamp, sequence, and macID
 * and generates a 64 bit long integer by performing bitwise operations
 * 
 * First 42 bits are filled with current timestamp
 * Next 10 bits are filled with the node/machine id (max size can be 1024)
 * Next 12 bits are filled with sequence which ensures that even if timestamp didn't change the value will be generated
 * 
 * Function can theorotically generate 1024 unique values within a millisecond without repeating values
*/
uint64_t nextID(uint64_t currentTimestamp, uint64_t lastTimestamp, uint64_t sequence, std::string macID)
{
    int NODEID = nodeID(macID);
    uint64_t id = currentTimestamp << (TOTAL_BITS - EPOCH_BITS);
    id |= (NODEID << (TOTAL_BITS - EPOCH_BITS - NODE_ID_BITS));
    id |= sequence;

    return id;
}

// ////////////////////////////////////////////////////////////////////////////////////////

/**
 * N-API wrapper for the nextID function
*/
Napi::Number nextIDWrapped(const Napi::CallbackInfo &info)
{
    Napi::Env env = info.Env();

    if (info.Length() < 4)
    {
        Napi::Error::New(env, "Insufficient arguments").ThrowAsJavaScriptException();
    }
    if (!info[0].IsNumber() || !info[1].IsNumber() || !info[2].IsNumber())
    {
        Napi::TypeError::New(env, "Number expected").ThrowAsJavaScriptException();
    }
    if (!info[3].IsString())
    {
        Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
    }

    Napi::Number first = info[0].As<Napi::Number>();
    Napi::Number second = info[1].As<Napi::Number>();
    Napi::Number third = info[2].As<Napi::Number>();
    Napi::String fourth = info[3].As<Napi::String>();

    uint64_t returnValue = nextID(first.Int64Value(), second.Int64Value(), third.Int64Value(), fourth.Utf8Value());

    return Napi::Number::New(env, returnValue);
}

// ////////////////////////////////////////////////////////////////////////////////////////

/**
 * Convert generated number 64 bit integer to a string
*/
std::string nextIDString(uint64_t currentTimestamp, uint64_t lastTimestamp, uint64_t sequence, std::string macID)
{
    return std::to_string(nextID(currentTimestamp, lastTimestamp, sequence, macID));
}

// ////////////////////////////////////////////////////////////////////////////////////////

/**
 * N-API wrapper for the nextIDString function
*/
Napi::String nextIDStringWrapped(const Napi::CallbackInfo &info)
{
    Napi::Env env = info.Env();

    if (info.Length() < 4)
    {
        Napi::Error::New(env, "Insufficient arguments").ThrowAsJavaScriptException();
    }
    if (!info[0].IsNumber() || !info[1].IsNumber() || !info[2].IsNumber())
    {
        Napi::TypeError::New(env, "Number expected").ThrowAsJavaScriptException();
    }
    if (!info[3].IsString())
    {
        Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
    }

    Napi::Number first = info[0].As<Napi::Number>();
    Napi::Number second = info[1].As<Napi::Number>();
    Napi::Number third = info[2].As<Napi::Number>();
    Napi::String fourth = info[3].As<Napi::String>();

    std::string returnValue = nextIDString(first.Int64Value(), second.Int64Value(), third.Int64Value(), fourth.Utf8Value());

    return Napi::String::New(env, returnValue);
}

// ////////////////////////////////////////////////////////////////////////////////////////

/**
 * Returns timestamp at which the id was generated by retreiving
 * the first 42 bits of the id, which are filled with current timestamp
 * bits
*/
uint64_t getTimestamp(uint64_t uniqueID)
{
    uint64_t timestamp = uniqueID >> (TOTAL_BITS - EPOCH_BITS);

    return timestamp;
}

/**
 * Overload for string inputs
*/
uint64_t getTimestamp(std::string uniqueID)
{
    uint64_t ID = std::stoull(uniqueID);

    uint64_t timestamp = ID >> (TOTAL_BITS - EPOCH_BITS);

    return timestamp;
}

// ////////////////////////////////////////////////////////////////////////////////////////

/**
 * N-API wrapper for getTimestamp function
*/
Napi::Number getTimestampWrapped(const Napi::CallbackInfo &info)
{
    Napi::Env env = info.Env();
    uint64_t returnValue = 0;

    if (info.Length() < 1)
    {
        Napi::Error::New(env, "No argument provided").ThrowAsJavaScriptException();
    }
    if (!info[0].IsNumber() && !info[0].IsString())
    {
        Napi::TypeError::New(env, "Expected a number or a string").ThrowAsJavaScriptException();
    }

    if (info[0].IsNumber())
    {
        Napi::Number first = info[0].As<Napi::Number>();

        returnValue = getTimestamp(first.Int64Value());
    }
    else if (info[0].IsString())
    {
        Napi::String first = info[0].As<Napi::String>();

        returnValue = getTimestamp(first.Utf8Value());
    }

    return Napi::Number::New(env, returnValue);
}

// ////////////////////////////////////////////////////////////////////////////////////////

Napi::Object InitAll(Napi::Env env, Napi::Object exports)
{
    exports.Set("nextID", Napi::Function::New(env, nextIDWrapped));
    exports.Set("nextIDString", Napi::Function::New(env, nextIDStringWrapped));
    exports.Set("getTimestamp", Napi::Function::New(env, getTimestampWrapped));
    return exports;
}

NODE_API_MODULE(snowflake, InitAll)