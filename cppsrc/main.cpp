/* cppsrc/main.cpp */
#include <napi.h>
#include <cstdint>
#include <string>
#include <cmath>
#include <functional>

int TOTAL_BITS = 64;
int EPOCH_BITS = 42;
int NODE_ID_BITS = 10;
int SEQUENCE_BITS = 12;

/** 
 * Max node that can be used
*/
uint64_t maxNodeId = std::pow(2, NODE_ID_BITS) - 1;

/**
 * Covert the macID string passed as a parameter
 * into a hash value and return the bitwise & with maxNodeID
 * so that the hashed value is always smaller than maxNodeID 
 * which is 10 bits in size
*/
int nodeID(std::string macID)
{
    return std::hash<std::string>()(macID) % maxNodeId;
}

/**
 * Takes the current timestamp, last timestamp, sequence, and macID
 * and generates a 64 bit long integer by performin bitwise operations
 * 
 * First 42 bits are filled with current timestamp
 * Next 10 bits are filled with the node/machine id (max size can be 1024)
 * Next 12 bits are filled with sequence which ensures that even if timestamp didn't change the value will be generated
 * 
 * Function can generate 4096 unique values within a millisecond without repeating values
*/
uint64_t nextID(uint64_t currentTimestamp, uint64_t lastTimestamp, uint64_t sequence, std::string macID)
{
    int NODEID = nodeID(macID);
    uint64_t id = currentTimestamp << (TOTAL_BITS - EPOCH_BITS);
    id |= (NODEID << (TOTAL_BITS - EPOCH_BITS - NODE_ID_BITS));
    id |= sequence;

    return id;
}

/**
 * N-API wrapper for the nextID function
*/
Napi::Number nextIDWrapped(const Napi::CallbackInfo &info)
{
    Napi::Env env = info.Env();

    if (info.Length() < 4)
    {
        Napi::Error::New(env, "Insufficient arguments").ThrowAsJavaScriptException();
    }
    if (!info[0].IsNumber() || !info[1].IsNumber() || !info[2].IsNumber())
    {
        Napi::TypeError::New(env, "Number expected").ThrowAsJavaScriptException();
    }
    if (!info[3].IsString())
    {
        Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
    }

    Napi::Number first = info[0].As<Napi::Number>();
    Napi::Number second = info[1].As<Napi::Number>();
    Napi::Number third = info[2].As<Napi::Number>();
    Napi::String fourth = info[3].As<Napi::String>();

    uint64_t returnValue = nextID(first.Int64Value(), second.Int64Value(), third.Int64Value(), fourth.Utf8Value());

    return Napi::Number::New(env, returnValue);
}

/**
 * Returns timestamp at which the id was generated by retreiving
 * the first 42 bits of the id, which are filled with crrent timestamp
 * bits
*/
uint64_t getTimestamp(uint64_t uniqueID)
{
    uint64_t timestamp = uniqueID >> (TOTAL_BITS - EPOCH_BITS);

    return timestamp;
}

/**
 * N-API wrapper for getTimestamp function
*/
Napi::Number getTimestampWrapped(const Napi::CallbackInfo &info)
{
    Napi::Env env = info.Env();

    if (info.Length() < 1)
    {
        Napi::Error::New(env, "No argument provided").ThrowAsJavaScriptException();
    }
    if (!info[0].IsNumber())
    {
        Napi::TypeError::New(env, "Expected a number").ThrowAsJavaScriptException();
    }

    Napi::Number first = info[0].As<Napi::Number>();

    uint64_t returnValue = getTimestamp(first.Int64Value());

    return Napi::Number::New(env, returnValue);
}

Napi::Object InitAll(Napi::Env env, Napi::Object exports)
{
    exports.Set("nextID", Napi::Function::New(env, nextIDWrapped));
    exports.Set("getTimestamp", Napi::Function::New(env, getTimestampWrapped));
    return exports;
}

NODE_API_MODULE(snowflake, InitAll)